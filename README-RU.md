# Лабораторная работа 2 по алгоритмам
[English version](https://github.com/khadievedem/algorithms-lab-2/blob/main/README.md)

Задача, которую решают алгоритмы - нахождение количества прямоугольников, в которых лежит точка.
Было реализовано и протестировано три различных алгоритма. Чтобы определить наиболее эффективный алгоритм, они были протестированы на различных объемах исходных данных. 

## Содержание

- [Введение](#введение)
- [Как запустить тесты](#как-запустить-тесты)
- [Сравнение производительности](#сравнение-производительности)
- [Графики](#графики)
- [Заключение](#заключение)

## Введение

Лабораторная работа состоит в реализации и сравнении производительности трех различных алгоритмов:

1. Алгоритм полного перебора
2. Алгоритм сжатой карты
3. Алгоритм персистентного дерева

Каждый алгоритм был реализован на Rust и протестирован на наборе данных из [1..200000] точек и [1..200000] прямоугольников.

## Как запустить тесты

Чтобы запустить тесты, выполните следующие действия:

1. Клонируйте репозиторий
2. Прочитайте [Установку](https://doc.rust-lang.org/book/ch01-01-installation.html) из книги ['The Rust Programming Language'](https://doc.rust-lang.org/book/index.html).
3. Перейдите в директорию проекта в вашем терминале
4. Запустите `cargo build --release`, чтобы построить проект
5. Запустите `cargo test -r -- --show-output`, чтобы запустить проект

## Сравнение производительности
Измеренная сложность, которая была дана ранее:

| Алгоритм | Временная сложность | Подготовка |
|-----------|----------------|------------------|
| Полный перебор | O(N) | O(1) |
| Сжатая карта | O(log(N)) | O(N^3) |
| Персистентное дерево | O(log(N)) | O(Nlog(N)) |

## Графики
Графики ниже показывают результаты запуска алгоритмов на наборах данных и характеризуют временную сложность, а также сравнение между алгоритмами:

| Алгоритм на Карте | Алгоритм на персистентом дереве |
| ------ | ------ |
| ![Скорость-подготовки-алгоритма-на-Карте](https://raw.githubusercontent.com/khadievedem/algorithms-lab-2/main/graphics/%D0%A1%D0%BA%D0%BE%D1%80%D0%BE%D1%81%D1%82%D1%8C%20%D0%BF%D0%BE%D0%B4%D0%B3%D0%BE%D1%82%D0%BE%D0%B2%D0%BA%D0%B8%20%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0%20%D0%BD%D0%B0%20%D0%9A%D0%B0%D1%80%D1%82%D0%B5.png) | ![Скорость-подготовки-алгоритма-на-персистентном-дереве](https://raw.githubusercontent.com/khadievedem/algorithms-lab-2/main/graphics/%D0%A1%D0%BA%D0%BE%D1%80%D0%BE%D1%81%D1%82%D1%8C%20%D0%BF%D0%BE%D0%B4%D0%B3%D0%BE%D1%82%D0%BE%D0%B2%D0%BA%D0%B8%20%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0%20%D0%BD%D0%B0%20%D0%BF%D0%B5%D1%80%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BD%D1%82%D0%BE%D0%BC%20%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%B5.png) |

| Сравнение алгоритмов на персистентом дереве и на карте |
| ----- |
| ![Сравнение-графиков-подготовки-алгоритма-на-персистентном-дереве-и-на-карте](https://raw.githubusercontent.com/khadievedem/algorithms-lab-2/main/graphics/%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D0%BA%D0%BE%D0%B2%20%D0%BF%D0%BE%D0%B4%D0%B3%D0%BE%D1%82%D0%BE%D0%B2%D0%BA%D0%B8%20%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0%20%D0%BD%D0%B0%20%D0%BF%D0%B5%D1%80%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D0%BC%20%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%B5%20%D0%B8%20%D0%BD%D0%B0%20%D0%BA%D0%B0%D1%80%D1%82%D0%B5.png) |

| Среднее время поиска ответа на один запрос |
| ----- |
| ![Время-поиска-ответа-на-один-запрос-(сред.)](https://raw.githubusercontent.com/khadievedem/algorithms-lab-2/main/graphics/%D0%92%D1%80%D0%B5%D0%BC%D1%8F%20%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0%20%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D0%B0%20%D0%BD%D0%B0%20%D0%BE%D0%B4%D0%B8%D0%BD%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%20(%D1%81%D1%80).png) |

## Заключение
Результаты показали, что при подготовке данных алгоритм на карте является самым медленным (как и предполагалось), занимая O(n^3) для построения 2D-карты на сжатых координатах. С другой стороны, алгоритм полного перебора имел сложность O(1) в подготовке (потому что подготовки вообще нет :) ), в то время как алгоритм на персистентном дереве подготавливался за O(n log(n)). Персистентное дерево и алгоритм на карте не пересекались по сложности подготовки данных, что говорит нам о том, что алгоритм на карте сильно дольше готовит данные.

Из графика видно, что алгоритм полного перебора имеет стабильную сложность O(n) для ответа на запрос, в то время как у других двух алгоритмов сложность составляет около O(log(n)). Также, посмотрев на график можно сделать вывод, что до тех пор, пока количество прямоугольников не достигнет примерно 500, все три алгоритма одинаково эффективно отвечают на запросы.

Алгоритм полного перебора может быть наиболее эффективным для небольших наборов данных, в то время как алгоритм на постоянном дереве и алгоритм на карте могут быть более эффективными для больших.
